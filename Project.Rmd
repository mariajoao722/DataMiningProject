---
title: "Project"
author: "Maria Pais, Mónica Araújo"
date: "2023-11-07"
output:
  html_document:
    number_sections: yes
    theme: flatly  # journal flatly spacelab cosmo
    highlight: tango
    toc : yes
    toc_float:
      collapsed: true
      smoth_scroll: true
  word_document: 
    toc :yes
  pdf_document:
    toc : yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE
)
```

<!-- load packagers -->
<!-- include = false is for Hiding the code and the output in final file-->
```{r, include = FALSE}
library(tidyverse)
library(tidymodels)
library(readr)
library(dplyr)
library(ggplot2)

```

<!-- load the databases -->
```{r, include = FALSE}
# Load or create the loan_dev dataset
loan_dev <- read_delim("loan_dev.csv", delim = ";", 
    escape_double = FALSE, trim_ws = TRUE)

disp <- read_delim("disp.csv", delim = ";", 
    escape_double = FALSE, trim_ws = TRUE)

trans_dev <- read_delim("trans_dev.csv", delim = ";", 
    escape_double = FALSE, trim_ws = TRUE)

account <- read_delim("account.csv", delim = ";", 
    escape_double = FALSE, trim_ws = TRUE)

card_dev <- read_delim("card_dev.csv", delim = ";", 
    escape_double = FALSE, trim_ws = TRUE)

client <- read_delim("client.csv", delim = ";", 
    escape_double = FALSE, trim_ws = TRUE)

district <- read_delim("district.csv", delim = ";", 
    escape_double = FALSE, trim_ws = TRUE)

```

# Data Understanding Maria

The data understanding phase of CRISP-DM involves taking a closer look at the data available for mining. This step is critical in avoiding unexpected problems during the next phase, data preparation, which is typically the longest part of a project.

Data understanding involves accessing the data and exploring it using tables and graphics. This enables you to determine the quality of the data and describe the results of these steps in the project documentation.


trans_dev account final n interessa, bank, k_symbol posso apagar

na data do loan ver a ultima transação feita e podemos eliminar anteriores

## Data Summarizing

The term Data Summarizing can be defined as the presentation of a summary/report of generated data in a comprehensible and informative manner.Data summarizing is typically numerical, visual or a combination of the two. It is a key skill in data analysis - we use it to provide insights both to others and to ourselves. 


Nesta linha de código vemos o número de empréstimos em que o contrato acabou sem problemas ("1") e aqueles em que o contrato acabou ou o empréstimo ainda não foi pago.

```{r}
loan_dev %>%
     group_by(status) %>%
     count()
```

Para juntar a informação  do estado dos empréstimos com o id do cliente foi preciso dar merge a dois datasets, mas para não juntar colunas desnecessárias primeiro escolhemos as colunas necesárias.

```{r}
selected_columns <- loan_dev %>%
    select(account_id, status)
```

Após selecionar as colunas vamos dar merge do novo dataset criado com o dataset disp.

```{r}
merge_loan_disp <- merge(selected_columns, disp, by = "account_id")
```

## Data Visualizing

Data visualization is the representation of data through use of common graphics, such as charts and plots. These visual displays of information communicate complex data relationships and data-driven insights in a way that is easy to understand.

Mostra a distribuição das transações pelo tipo de operação 

```{r}
ggplot(trans_dev, aes(x = operation)) + geom_bar() + ggtitle("Distribution of transactions across operation") + theme(legend.text = element_text(size = 5))
```



# Data Preparation Mónica
Data cleaning:

- [X]  Handle missing values;
- [x]  Duplicate records;
- [ ]  errors in the data;

Data transformation:

- [ ]  Feature engineering;
- [ ]  Scaling
- [ ]  Encoding categorical variables
- [x]  Date and time parsing
- [ ]  text data processing

Handling Imbalanced Data:

- [ ] Oversampling...;

Data splitting:

- [ ] split data into training and test

## Conversão do tipo de dados (Data Structure) 

Conversão do tipos de dados, garantindo a consistência e adequação dos tipos de dados para análises e visualizações e facilitando operações específicas, como ordenação e filtragem.

Nota: Na conversão da data foi utilizada a adição do século '19' para garantir a interpretação correta do ano.


````{r}

account$account_id <- as.integer(account$account_id)
account$district_id <- as.factor(account$district_id)
account$frequency <- as.factor(account$frequency)
if(!inherits(account$date, "Date")){
  account$date <- as.Date(sprintf("%s%s", "19", account$date), format="%Y%m%d")
}

save(account, file="Rdata/account.Rdata")
#load()
str(account)
cat("\n")
summary(account)

`````

````{r}

card_dev$card_id <- as.integer(card_dev$card_id)
card_dev$disp_id <- as.integer(card_dev$disp_id)
card_dev$type <- as.factor(card_dev$type)
if(!inherits(card_dev$issued, "Date")){
  card_dev$issued <- as.Date(sprintf("%s%s", "19", card_dev$issued), format="%Y%m%d")
}
str(card_dev)
cat("\n")
summary(card_dev)

save(card_dev, file="Rdata/card_dev.Rdata")

`````

````{r}
client$client_id <- as.integer(client$client_id)
client$birth_number <- as.integer(client$birth_number)
client$district_id <- as.factor(client$district_id)

str(client)
cat("\n")
summary(client)

save(client, file="Rdata/client.Rdata")

`````


````{r}
disp$disp_id <- as.integer(disp$disp_id)
disp$client_id <- as.integer(disp$client_id)
disp$account_id <- as.integer(disp$account_id)
disp$type <- as.factor(disp$type)


str(disp)
cat("\n")
summary(disp)

save(disp, file="Rdata/disp.Rdata")

`````

````{r}
district$code <- as.integer(district$code)
district$region <- as.factor(district$region)
district$`no. of inhabitants` <- as.integer(district$`no. of inhabitants`)
district$`no. of municipalities with inhabitants < 499` <- as.integer(district$`no. of municipalities with inhabitants < 499`)
district$`no. of municipalities with inhabitants 500-1999` <- as.integer(district$`no. of municipalities with inhabitants 500-1999`)
district$`no. of municipalities with inhabitants 2000-9999` <- as.integer(district$`no. of municipalities with inhabitants 2000-9999`)
district$`no. of municipalities with inhabitants >10000` <- as.integer(district$`no. of municipalities with inhabitants >10000`)
district$`no. of cities` <- as.integer(district$`no. of cities`)
district$`unemploymant rate '95` <- as.numeric(district$`unemploymant rate '95`)
district$`unemploymant rate '96` <- as.numeric(district$`unemploymant rate '96`)
district$`no. of commited crimes '95` <- as.numeric(district$`no. of commited crimes '95`)
district$`no. of commited crimes '96` <- as.numeric(district$`no. of commited crimes '96`)

str(district)
cat("\n")
summary(district)
save(district, file="Rdata/district.Rdata")
`````

````{r}
loan_dev$loan_id <- as.integer(loan_dev$loan_id)
loan_dev$account_id <- as.integer(loan_dev$account_id)

if(!inherits(loan_dev$date, "Date")){
  loan_dev$date <- as.Date(sprintf("%s%s", "19", loan_dev$date), format="%Y%m%d")
}
loan_dev$status <- as.factor(loan_dev$status)

str(loan_dev)
cat("\n")
summary(loan_dev)

save(loan_dev, file="Rdata/loan_dev.Rdata")
`````

````{r}
trans_dev$trans_id <- as.integer(trans_dev$trans_id)
trans_dev$account_id <- as.integer(trans_dev$account_id)
if(!inherits(trans_dev$date, "Date")){
  trans_dev$date <- as.Date(sprintf("%s%s", "19", trans_dev$date), format="%Y%m%d")
}
trans_dev$operation <- as.factor(trans_dev$operation)
trans_dev$k_symbol <- as.factor(trans_dev$k_symbol)
trans_dev$account <- as.integer(trans_dev$account)

str(trans_dev)
cat("\n")
summary(trans_dev)
save(trans_dev, file="Rdata/trans_dev.Rdata")
````

## Missing values

### Missing Values Analysis and Column Removal

\* Remove the properties with more than 50% missing values

````{r}
datasets <- list (account, card_dev, client, disp, district, loan_dev, trans_dev)
names <- list("account", "card_dev", "client", "disp", "district", "loan_dev", "trans_dev")

for (i in seq_along(datasets)){
  
  dataset <- datasets[[i]]

  numeroNa <- dataset %>%
      summarise_all(~sum(is.na(.)))
  
  if(sum(numeroNa) > 0){
    cat("Missing values in", names[[i]], "dataset:\n")
    
    for (col_name in names(numeroNa)) {
      cat("  ",col_name, ": ",  sprintf("%.1f%%", numeroNa[[col_name]]/ length(dataset[[col_name]])*100))
      
      if(numeroNa[[col_name]]/ length(dataset[[col_name]])*100 > 50){
        cat("  ", "**", col_name, "property removed **\n")
        dataset <- subset(dataset, select = -get(col_name))
        #datasets[[i]] <- dataset
        
      } else{
        cat("\n")
      }
    }
    cat("\n")
  } else {
   cat("No missing values in", names[[i]], "dataset\n")
  }
  new_dataset_name <- paste(names[[i]], "_transform", sep = "")
  assign(new_dataset_name, dataset)
  
}
rm(datasets)
rm(names)

````

### Imputation of missing values

#### Analysis of what value to impute in the trans_dev dataset
````{r}
#trans_dev$status <- ifelse(is.na(trans_dev$bank), "NA", "Not NA")
#trans_dev$statusKey <- ifelse(is.na(trans_dev$k_symbol), "NA", "Not NA")
trans_dev$statusAccount <- ifelse(is.na(trans_dev$account), "NA", "Not NA")
#trans_dev$statusOperation <- ifelse(is.na(trans_dev$operation), "NA", "Not NA")


#test_single <- unique(trans_dev$k_symbol)
#test_combine <- unique(trans_dev[, c("operation", "k_symbol")])
#sort_test_combine <- test_combine[order(test_combine$k_symbol, test_combine$operation), ]

#test_combine_operation <- unique(trans_dev[, c("statusOperation", "k_symbol")])
#sort_test_combine_operation <- test_combine_operation[order(test_combine_operation$statusOperation, test_combine_operation$k_symbol), ]

#test_3_combine <- unique((trans_dev[, c("operation", "status", "statusKey")]))
#sort_test_3_combine <- test_3_combine [order(test_3_combine$status, test_3_combine$statusKey, test_3_combine$operation), ]

#test_4_combine <- unique((trans_dev[, c("operation", "status", "statusKey", "statusAccount")]))
#sort_test_4_combine <- test_4_combine [order(test_4_combine$status, test_4_combine$statusKey, test_4_combine$statusAccount,  test_4_combine$operation), ]

#test_5_combine <- unique((trans_dev[, c("operation","type", "status", "statusKey", "statusAccount")]))
#sort_test_5_combine <- test_5_combine [order(test_5_combine$type, test_5_combine$status, test_5_combine$statusKey, test_5_combine$statusAccount,  test_5_combine$operation), ]

test_f_combine <- unique((trans_dev[, c("operation","type", "statusAccount")]))
sort_test_f_combine <- test_f_combine [order(test_f_combine$type, test_f_combine$statusAccount,  test_f_combine$operation), ]


#print(test_single)
#print(test_combine)
#print(sort_test_combine)

#print(test_3_combine)
#print(sort_test_3_combine)

#print(test_4_combine)
#print(sort_test_4_combine)


#print(test_5_combine)
#print(sort_test_5_combine)

#print(test_f_combine)
print(sort_test_f_combine)

`````
Com o codigo anterior podemos observar que com grande provabilidade o NA na operation é "credit in cash"


#### Imputing Missing Values in the trans_dev Dataset
````{r}

antes <- c(
  NA_count = sum(is.na(trans_dev$operation)),
  creditInCash_count = sum(trans_dev$operation == "credit in cash", na.rm = TRUE)
)
print(antes)
cat("\n")

trans_dev_transform$operation <- ifelse(
  is.na(trans_dev$operation),
  "credit in cash", 
  as.character(trans_dev$operation)
  )



depois <- c(
  NA_count = sum(is.na(trans_dev_transform$operation)),
  creditInCash_count = sum(trans_dev_transform$operation == "credit in cash")
)
print(depois)

````
Tratar dos missing values no dataset District

````{r}
district_transform$`unemploymant rate '95` <- ifelse(is.na(district$`unemploymant rate '95`),
                            round(mean(district$`unemploymant rate '95`, na.rm = TRUE), 2),
                             district$`unemploymant rate '95`
                             )

district_transform$`no. of commited crimes '95` <- ifelse(is.na(district$`no. of commited crimes '95`),
                             round(mean(district$`no. of commited crimes '95`, na.rm = TRUE), 0),
                             district$`no. of commited crimes '95`
                             )
````

## Duplicate Values

````{r}
datasets <- list (account, card_dev, client, disp, district, loan_dev, trans_dev)
names <- list("account", "card_dev", "client", "disp", "district", "loan_dev", "trans_dev")

for (i in seq_along(datasets)){
  
  dataset <- datasets[[i]]

  duplicate_rows <- dataset[duplicated(dataset), ]
  
  if(sum(duplicate_rows) > 0){
    cat(sum(duplicate_rows), "duplicat values in", names[[i]], "dataset\n")
    
  } else {
   cat("No duplicate values in", names[[i]], "dataset\n")
  }
  new_dataset_name <- paste(names[[i]], "_transform", sep = "")
  assign(new_dataset_name, dataset)
  
}
rm(datasets)
rm(names)

include_columns <- c("account_id")
duplicate_rows <-  account[duplicated(account[, include_columns]), ]
print(sum(duplicate_rows))

include_columns <- c("card_id", "disp_id")
duplicate_rows <-  card_dev[duplicated(card_dev[, include_columns]), ]
print(sum(duplicate_rows))

include_columns <- c("client_id", "district_id")
duplicate_rows <-  client[duplicated(client[, include_columns]), ]
print(sum(duplicate_rows))

include_columns <- c("code", "name", "region")
duplicate_rows <- district[duplicated(district[, include_columns]), ]
print(sum(duplicate_rows))


````
## Handle errors in data


````{r}
account$account_id <- as.integer(account$account_id)
account$district_id <- as.factor(account$district_id)
str(account)
summary(account)
boxplot(account$date)
hist(account$date, breaks = "months", xlab="Date by months", ylab = "density", main = "Histogram of dates")
````


# Descriptive Modelling Mónica

\* cluster com distritos

# Predictive Modelling Maria .

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.